stages:
  - scan

variables:
  AZURE_CLOUD: "AzureCloud"

aks-version-scan:
  image: mcr.microsoft.com/azure-cli:2.64.0
  stage: scan
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    - if: '$CI_PIPELINE_SOURCE == "push"'
  before_script:
    - mkdir -p report
    - az cloud set --name ${AZURE_CLOUD:-AzureCloud}
    - az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
    - az account set --subscription "$AZURE_SUBSCRIPTION_ID"
    - |
      if ! command -v jq >/dev/null 2>&1; then
        if command -v apt-get >/dev/null 2>&1; then
          apt-get update -y && apt-get install -y jq && rm -rf /var/lib/apt/lists/*
        elif command -v apk >/dev/null 2>&1; then
          apk add --no-cache jq
        elif command -v microdnf >/dev/null 2>&1; then
          microdnf install -y jq && microdnf clean all
        else
          echo "No supported package manager found to install jq" >&2; exit 1
        fi
      fi
  script:
    - |
      set -euo pipefail

      echo "Listing AKS clusters in subscription $AZURE_SUBSCRIPTION_ID"
      az aks list --subscription "$AZURE_SUBSCRIPTION_ID" -o json > report/aks_clusters_raw.json

      # Normalize basic cluster info
      jq -r '
        map({
          name: .name,
          resourceGroup: .resourceGroup,
          location: .location,
          currentVersion: (.kubernetesVersion // .currentKubernetesVersion // ""),
          autoUpgradeChannel: (.autoUpgradeProfile.upgradeChannel // ""),
          provisioningState: .provisioningState
        })
      ' report/aks_clusters_raw.json > report/aks_clusters_basic.json

      echo "Computing latest patch, node pool versions, and upgrade info per cluster"
      jq -c '.[]' report/aks_clusters_basic.json | while read -r cluster; do
        NAME=$(echo "$cluster" | jq -r .name)
        RG=$(echo "$cluster" | jq -r .resourceGroup)
        CURR=$(echo "$cluster" | jq -r .currentVersion)

        # Query available upgrades for this cluster
        UPG=$(az aks get-upgrades -g "$RG" -n "$NAME" -o json)

        CURR_FROM_UPG=$(echo "$UPG" | jq -r '.controlPlaneProfile.kubernetesVersion')
        CURRENT_VERSION=${CURR:-$CURR_FROM_UPG}

        if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "null" ]; then
          CURRENT_VERSION=""
        fi

        if [ -n "$CURRENT_VERSION" ]; then
          MAJOR_MINOR=$(echo "$CURRENT_VERSION" | awk -F. '{print $1 "." $2}')
        else
          MAJOR_MINOR=""
        fi

        # Highest patch for the same minor version (including current)
        LATEST_SAME_MINOR=$(echo "$UPG" | jq -r --arg mm "$MAJOR_MINOR" '
          [
            .controlPlaneProfile.upgrades[]?.kubernetesVersion
            | select($mm != "" and startswith($mm + "."))
          ] | (if $mm == "" then [] else . end)
            | map(.) + [ .controlPlaneProfile.kubernetesVersion ]
            | unique | sort | last // ""
        ')

        # Next minor version candidates (greater minor than current), as JSON array
        NEXT_MINOR_CANDIDATES_JSON=$(echo "$UPG" | jq -c --arg mm "$MAJOR_MINOR" '
          (
            if $mm == "" then [] else
            [
              .controlPlaneProfile.upgrades[]?.kubernetesVersion
              | select((. | startswith($mm + ".")) | not)
            ]
            end
          ) | unique | sort
        ')

        NEW_MINOR_AVAILABLE=$(echo "$NEXT_MINOR_CANDIDATES_JSON" | jq 'length > 0')
        NEW_MINOR_AVAILABLE=$(echo "$NEW_MINOR_AVAILABLE" | tr -d '\n\r')

        AUTO_CHANNEL=$(echo "$cluster" | jq -r '.autoUpgradeChannel')

        # Node pool versions
        NODEPOOLS=$(az aks nodepool list -g "$RG" --cluster-name "$NAME" -o json | jq '[.[] | {name: .name, mode: .mode, orchestratorVersion: .orchestratorVersion}]')

        jq -n --argjson base "$cluster" \
              --arg currentVersion "$CURRENT_VERSION" \
              --arg latestSameMinor "$LATEST_SAME_MINOR" \
              --argjson nextMinorCandidates "$NEXT_MINOR_CANDIDATES_JSON" \
              --argjson newMinorAvailable "$NEW_MINOR_AVAILABLE" \
              --arg autoUpgradeChannel "$AUTO_CHANNEL" \
              --argjson nodepools "$NODEPOOLS" '
          $base + {
            currentVersion: $currentVersion,
            latestPatchSameMinor: $latestSameMinor,
            newMinorAvailable: $newMinorAvailable,
            nextMinorVersions: $nextMinorCandidates,
            autoUpgradeChannel: $autoUpgradeChannel,
            nodePools: $nodepools
          }
        '
      done | jq -s '.' > report/aks_versions.json

      # CSV summary (control plane only)
      jq -r '
        (["name","resourceGroup","location","currentVersion","latestPatchSameMinor","newMinorAvailable","autoUpgradeChannel"] | @csv),
        (.[] | [
          .name, .resourceGroup, .location,
          .currentVersion, .latestPatchSameMinor,
          (if .newMinorAvailable then "true" else "false" end),
          .autoUpgradeChannel
        ] | @csv)
      ' report/aks_versions.json > report/aks_versions.csv

      echo "Report written to report/aks_versions.json and report/aks_versions.csv"
  artifacts:
    when: always
    paths:
      - report/aks_versions.json
      - report/aks_versions.csv
  after_script:
    - az logout || true
  timeout: 30m